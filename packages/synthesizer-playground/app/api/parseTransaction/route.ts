// app/api/parseTransaction/route.ts
import { NextResponse } from 'next/server';
import { fetchTransactionBytecode } from '../../utils/etherscanApi';

export async function POST(request: Request) {
  try {
    const { txId } = await request.json();
    if (!txId) {
      return NextResponse.json({ ok: false, error: 'No transaction ID provided' }, { status: 400 });
    }

    // Fetch bytecode from Etherscan
    const { bytecode, from, to } = await fetchTransactionBytecode(txId);
    if (!bytecode || !from || !to) {
      throw new Error('Invalid transaction data from Etherscan');
    }

    // Dynamically import the synthesizer adapter so that it loads at runtime
    const { SynthesizerAdapter } = await import('@tokamak-zk-evm/synthesizer');
    const adapter = new SynthesizerAdapter();
    const { executionResult, permutation, placementInstance } =
      await adapter.parseTransaction({
        contractAddr: to,
        calldata: bytecode,
        sender: from,
      });

    if (!executionResult.runState?.synthesizer?.placements) {
      throw new Error('No placements generated by the synthesizer.');
    }

    const placementsMap = executionResult.runState.synthesizer.placements;
    const storageLoadPlacement = placementsMap.get(1); // STORAGE_IN_PLACEMENT_INDEX
    const logsPlacement = placementsMap.get(2);        // RETURN_PLACEMENT_INDEX
    const storageStorePlacement = placementsMap.get(3);  // STORAGE_OUT_PLACEMENT_INDEX

    const storageLoad = storageLoadPlacement?.inPts || [];
    const storageStore = storageStorePlacement?.outPts || [];
    const _logsData = logsPlacement?.outPts || [];

    const logs: Array<{ topics: string[]; valueDec: string; valueHex: string }> = [];
    let prevIdx = -1;
    for (const _logData of _logsData) {
      const idx = _logData.pairedInputWireIndices![0];
      if (idx !== prevIdx) {
        logs.push({ 
          topics: [], 
          valueDec: _logData.value.toString(),
          valueHex: _logData.valueHex 
        });
      } else {
        logs[idx].topics.push(_logData.valueHex);
      }
      prevIdx = idx;
    }

    function convertBigIntsToStrings(obj: any) {
      return JSON.parse(JSON.stringify(obj, (_, value) =>
        typeof value === 'bigint' ? value.toString() : value
      ));
    }

    return NextResponse.json({
      ok: true,
      data: {
        from,
        to,
        logs,
        storageLoad: convertBigIntsToStrings(storageLoad),
        storageStore: convertBigIntsToStrings(storageStore),
        permutation: convertBigIntsToStrings(permutation),
        placementInstance: convertBigIntsToStrings(placementInstance),
      },
    });
  } catch (error: any) {
    console.error('Error in /api/parseTransaction:', error);
    return NextResponse.json({ ok: false, error: error.message }, { status: 500 });
  }
}
