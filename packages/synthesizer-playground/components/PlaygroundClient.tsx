'use client';

import { useState, useEffect } from 'react';
import { Buffer } from 'buffer';
import { TON_CONTRACT_CODE } from '@/app/constant/evm';
import { setupEVM } from '@/utils/setupEVM';
import { serializePlacements } from '@/helpers/helpers';
import { fetchTransactionBytecode } from '@/utils/etherscanApi';
import { MockSynthesizerAdapter } from '../mocks/synthesizer-adapter';
import { SynthesizerResponse } from '../mocks/synthesizer-adapter';

import Header from '@/components/Header';
import TransactionForm from '@/components/TransactionForm';
import ResultDisplay from '@/components/ResultDisplay';
import CustomLoading from '@/components/CustomLoading';
import CustomErrorTab from '@/components/CustomErrorTab';
import Stars from '@/components/Stars';
import RainbowImage from '@/components/RainbowImage';
import TokenForm from './TokenForm';

// Polyfill Buffer for browser
if (typeof window !== 'undefined') {
  window.Buffer = window.Buffer || Buffer;
}

export default function PlaygroundClient() {
  const [transactionId, setTransactionId] = useState('');
  const [status, setStatus] = useState<string | null>(null);
  const [serverData, setServerData] = useState<{
    permutation: string | null;
    placementInstance: string | null;
  } | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);

  const [storageLoad, setStorageLoad] = useState<any[]>([]);
  const [placementLogs, setPlacementLogs] = useState<any[]>([]);
  const [storageStore, setStorageStore] = useState<any[]>([]);
  const [evmContractAddress, setEvmContractAddress] = useState<string>('');
  const [activeTab, setActiveTab] = useState('storageLoad');

  const [tokenData, setTokenData] = useState<SynthesizerResponse | null>(null);
  const [error, setError] = useState<string | null>(null);

  const synthesizer = new MockSynthesizerAdapter();

  const processTransaction = async (txId: string) => {
    try {
      setIsProcessing(true);

      setStatus('Fetching bytecode from Etherscan...');
      setStorageLoad([]);
      setPlacementLogs([]);
      setStorageStore([]);
      setServerData(null);

      const { bytecode, from, to } = await fetchTransactionBytecode(txId);
      if (!bytecode || bytecode.length < 2) {
        throw new Error('Invalid bytecode received. Check your transaction ID.');
      }

      const contractCode = TON_CONTRACT_CODE;
      setStatus('Creating and running the EVM...');
      const evm = await mockCreateEVM();
      const contractAddr = mockAddress(to);
      const sender = mockAddress(from);
      setEvmContractAddress(contractAddr.toString());
      await setupEVM();

      const res = await evm.runCode({
        caller: sender,
        to: contractAddr,
        code: contractCode,
        data: mockHexToBytes(bytecode),
      });

      if (!res.runState?.synthesizer?.placements) {
        throw new Error('No placements generated by the synthesizer.');
      }

      const placementsMap = res.runState.synthesizer.placements;

      const {
        STORAGE_IN_PLACEMENT_INDEX,
        RETURN_PLACEMENT_INDEX,
        STORAGE_OUT_PLACEMENT_INDEX,
      } = await import('../../frontend/synthesizer/src/tokamak/constant/constants');
      
      const storageLoadPlacement = placementsMap.get(STORAGE_IN_PLACEMENT_INDEX);
      const logsPlacement = placementsMap.get(RETURN_PLACEMENT_INDEX);
      const storageStorePlacement = placementsMap.get(STORAGE_OUT_PLACEMENT_INDEX);

      const storageLoadData = storageLoadPlacement?.inPts || [];
      const storageStoreData = storageStorePlacement?.outPts || [];
      const _logsData = logsPlacement?.outPts || [];

      // Set all the data
      setStorageLoad(storageLoadData);
      setStorageStore(storageStoreData);
      const logsData = _logsData.map(log => ({
        topics: log.topics || [],
        valueDec: log.value || BigInt(0),
        valueHex: log.valueHex || '0x0'
      }));
      setPlacementLogs(logsData);

      const placementsObj = Object.fromEntries(placementsMap.entries());

      setStatus('Finalizing placements on the server...');
      const response = await fetch('/api/finalize', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: serializePlacements(placementsObj),
      });
      if (!response.ok) {
        throw new Error(`Server returned status ${response.status}`);
      }
      const json = await response.json();

      if (!json.ok) {
        throw new Error(json.error || 'Unknown server error.');
      }

      const { permutation, placementInstance } = json.data || {};
      setServerData({ permutation, placementInstance });
      setStatus(null);
      sessionStorage.removeItem('pendingTransactionId');
    } catch (error) {
      console.error('Error:', error);
      setStatus(`Error: ${error instanceof Error ? error.message : String(error)}`);
      sessionStorage.removeItem('pendingTransactionId');
    } finally {
      setIsProcessing(false);
    }
  };

  const handleSubmit = () => {
    if (isProcessing) return;
    sessionStorage.setItem('pendingTransactionId', transactionId);
    window.location.reload();
  };

  useEffect(() => {
    const pendingTxId = sessionStorage.getItem('pendingTransactionId');
    if (pendingTxId) {
      setTransactionId(pendingTxId);
      processTransaction(pendingTxId);
    }
  }, []);

  const handleDownload = (fileContent: string | null, fileName: string) => {
    if (!fileContent) return;
    const blob = new Blob([fileContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;
    link.click();
    URL.revokeObjectURL(url);
  };

  const handleTokenCheck = async (address: string) => {
    try {
      const data = await synthesizer.getTokenData(address);
      setTokenData(data);
      setError(null);
    } catch (err) {
      setError((err as Error).message);
      setTokenData(null);
    }
  };

  return (
    <>
      <div className="background-container">
        <Stars />
        <RainbowImage />
      </div>
      <div>
        <Header logo="/assets/logo.svg" onLogoClick={() => window.location.reload()} />
        <TransactionForm
          transactionId={transactionId}
          setTransactionId={setTransactionId}
          handleSubmit={handleSubmit}
          isProcessing={isProcessing}
          error={status?.startsWith('Error')}
        />
        
        <TokenForm onSubmit={handleTokenCheck} isProcessing={isProcessing} />
        
        {error && (
          <div className="p-4 mt-4 bg-red-800 rounded-lg text-white">
            {error}
          </div>
        )}
        {tokenData && (
          <div className="p-4 mt-4 bg-gray-800 rounded-lg">
            <h3 className="text-lg font-bold mb-2">Token Data</h3>
            <p>Address: {tokenData.tokenAddress}</p>
            <p>Balance: {tokenData.balance}</p>
          </div>
        )}

        {isProcessing ? (
          <CustomLoading />
        ) : status && status.startsWith('Error') ? (
          <CustomErrorTab errorMessage={status.replace('Error: ', '')} />
        ) : null}
        {!isProcessing && (storageLoad.length > 0 || placementLogs.length > 0 || storageStore.length > 0 || serverData) && (
          <ResultDisplay
            activeTab={activeTab}
            setActiveTab={setActiveTab}
            storageLoad={storageLoad}
            placementLogs={placementLogs}
            storageStore={storageStore}
            evmContractAddress={evmContractAddress}
            handleDownload={handleDownload}
            serverData={serverData}
          />
        )}
      </div>
    </>
  );
}

const mockAddress = (addr: string) => ({
  toString: () => addr,
  bytes: new Uint8Array(),
  equals: () => false,
  isZero: () => false,
  isPrecompileOrSystemAddress: () => false,
  toBytes: () => new Uint8Array()
});
const mockHexToBytes = (hex: string) => new Uint8Array();
const mockCreateEVM = async () => ({
  runCode: async () => ({
    runState: {
      synthesizer: {
        placements: new Map([
          // Mock storage load data (STORAGE_IN_PLACEMENT_INDEX)
          [0, {
            inPts: [
              { key: '0x123', value: '1000', valueHex: '0x3e8' },
              { key: '0x456', value: '2000', valueHex: '0x7d0' }
            ]
          }],
          // Mock logs data (RETURN_PLACEMENT_INDEX)
          [1, {
            outPts: [
              { 
                value: BigInt(100), 
                valueHex: '0x64',
                topics: ['0xTopic1'],  // Include topics directly in the log entry
                valueDec: BigInt(100)  // Add valueDec field
              },
              { 
                value: BigInt(200), 
                valueHex: '0xc8',
                topics: ['0xTopic2'],
                valueDec: BigInt(200)
              }
            ]
          }],
          // Mock storage store data (STORAGE_OUT_PLACEMENT_INDEX)
          [2, {
            outPts: [
              { key: '0x789', value: '3000', valueHex: '0xbb8' },
              { key: '0xabc', value: '4000', valueHex: '0xfa0' }
            ]
          }]
        ])
      }
    }
  })
}); 