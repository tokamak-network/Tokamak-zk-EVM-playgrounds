import 'dotenv/config';
import express, { Request, Response } from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import { SynthesizerAdapter } from '@tokamak-zk-evm/synthesizer';
import {
  STORAGE_IN_PLACEMENT_INDEX, 
  RETURN_PLACEMENT_INDEX, 
  STORAGE_OUT_PLACEMENT_INDEX 
} from '@tokamak-zk-evm/synthesizer';

// Adjust the import path if neededâ€”here we assume your utils are compiled from your Next.js app
import { fetchTransactionBytecode } from '../app/utils/etherscanApi.js';

const app = express();
app.use(cors());
app.use(bodyParser.json());

app.post('/api/parseTransaction', async (req: Request, res: Response) => {
  try {
    const { txId } = req.body;
    if (!txId) {
      return res.status(400).json({ ok: false, error: 'No transaction ID provided' });
    }

    // 1) Fetch bytecode, "from", and "to" from Etherscan
    const { bytecode, from, to } = await fetchTransactionBytecode(txId);
    if (!bytecode || !from || !to) {
      throw new Error('Invalid transaction data from Etherscan');
    }

    // 2) Create SynthesizerAdapter & parse the transaction
    const adapter = new SynthesizerAdapter();
    const { executionResult, permutation, placementInstance } = await adapter.parseTransaction({
      contractAddr: to,    // Must be TON, USDT, or USDC
      calldata: bytecode,  // The transaction input ("input" field)
      sender: from,
    });

    if (!executionResult.runState?.synthesizer?.placements) {
      throw new Error('No placements generated by the synthesizer.');
    }

    // 3) Extract logs/storage from the synthesizer placements
    const placementsMap = executionResult.runState.synthesizer.placements;

    const storageLoadPlacement = placementsMap.get(STORAGE_IN_PLACEMENT_INDEX);
    const logsPlacement = placementsMap.get(RETURN_PLACEMENT_INDEX);
    const storageStorePlacement = placementsMap.get(STORAGE_OUT_PLACEMENT_INDEX);

    const storageLoad = storageLoadPlacement?.inPts || [];
    const storageStore = storageStorePlacement?.outPts || [];
    const _logsData = logsPlacement?.outPts || [];

    // Parse logs
    const logs: Array<{ topics: string[]; valueDec: string; valueHex: string }> = [];
    let prevIdx = -1;
    for (const _logData of _logsData) {
      const idx = _logData.pairedInputWireIndices![0];
      if (idx !== prevIdx) {
        logs.push({ 
          topics: [], 
          valueDec: _logData.value.toString(), // Convert BigInt to string
          valueHex: _logData.valueHex 
        });
      } else {
        logs[idx].topics.push(_logData.valueHex);
      }
      prevIdx = idx;
    }

    // Helper function to convert BigInts to strings
    const convertBigIntsToStrings = (obj: any) => 
      JSON.parse(JSON.stringify(obj, (_, value) =>
        typeof value === 'bigint' ? value.toString() : value
      ));

    // 4) Return the final results
    res.json({
      ok: true,
      data: {
        from,
        to,
        logs,
        storageLoad: convertBigIntsToStrings(storageLoad),
        storageStore: convertBigIntsToStrings(storageStore),
        permutation: convertBigIntsToStrings(permutation),
        placementInstance: convertBigIntsToStrings(placementInstance),
      },
    });
  } catch (error: any) {
    console.error('Error in /api/parseTransaction:', error);
    res.status(500).json({ ok: false, error: error.message });
  }
});

app.listen(3002, () => {
  console.log('Server running on port 3002');
});
