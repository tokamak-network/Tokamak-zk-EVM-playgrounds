import { useState, useCallback, useEffect } from "react";
import { useAtomValue } from "jotai";
import { transactionHashAtom } from "../atoms/api";
import { useDocker } from "./useDocker";
import { RPC_URL } from "../constants";

// Types matching the SynthesizerResultModal requirements
export type StorageItem = {
  contractAddress?: string;
  key: string;
  valueDecimal?: string;
  valueHex: string;
};

export type LogItem = {
  topics?: string[];
  valueDec?: string;
  valueHex: string;
};

export type StorageStoreItem = {
  contractAddress?: string;
  key: string;
  value?: string;
  valueHex: string;
};

export type ServerData = {
  permutation?: string;
  placementInstance?: string;
};

export type SynthesizerResultData = {
  storageLoad: StorageItem[];
  placementLogs: LogItem[];
  storageStore: StorageStoreItem[];
  evmContractAddress: string;
  serverData: ServerData | null;
  isLoading: boolean;
  error: string | null;
};

export const useSynthesizerResult = (): SynthesizerResultData => {
  const transactionHash = useAtomValue(transactionHashAtom);
  const { executeCommand, currentDockerContainer } = useDocker();

  const [data, setData] = useState<SynthesizerResultData>({
    storageLoad: [],
    placementLogs: [],
    storageStore: [],
    evmContractAddress: "",
    serverData: null,
    isLoading: false,
    error: null,
  });

  // Helper function to safely convert BigInts to strings (same as server/index.ts)
  const convertBigIntsToStrings = useCallback((obj: unknown) => {
    try {
      return JSON.parse(
        JSON.stringify(obj, (_, value) =>
          typeof value === "bigint" ? value.toString() : value
        )
      );
    } catch (error) {
      console.error("Error converting BigInts to strings:", error);
      return [];
    }
  }, []);

  const fetchSynthesizerResult = useCallback(async () => {
    if (!transactionHash) {
      setData((prev) => ({
        ...prev,
        error: "Transaction hash not provided.",
        isLoading: false,
      }));
      return;
    }

    if (!currentDockerContainer?.ID) {
      setData((prev) => ({
        ...prev,
        isLoading: false,
        error: "Docker container not found. Please start the container first.",
      }));
      return;
    }

    try {
      setData((prev) => ({ ...prev, isLoading: true, error: null }));

      console.log("Processing transaction:", transactionHash);

      // Execute the synthesizer command in Docker container
      const result = await executeCommand(currentDockerContainer.ID, [
        "bash",
        "-c",
        `cd packages/frontend/synthesizer/examples/docker && 
        tsx index.ts ${RPC_URL} ${transactionHash}`,
      ]);

      console.log("Docker synthesizer result:", result);

      // Parse the result - assuming Docker returns { executionResult, permutation, placementInstance }
      let dockerResult;
      try {
        dockerResult = JSON.parse(result);
      } catch (parseError) {
        console.error("Failed to parse Docker result:", parseError);
        throw new Error("Invalid result format from Docker container");
      }

      const { executionResult, permutation, placementInstance } = dockerResult;

      // 3) Extract logs/storage from the synthesizer placements (same as server/index.ts)
      if (!executionResult.runState?.synthesizer?.placements) {
        throw new Error("No placements generated by the synthesizer.");
      }

      const placementsMap = executionResult.runState.synthesizer.placements;
      console.log("placementInstance", placementInstance);

      // For now, let's assume we get them from the Docker result or use default values
      const placementIndices = dockerResult.placementIndices || {
        storageIn: 0,
        return: 1,
        storageOut: 2,
      };

      console.log("Placement indices:", placementIndices);

      const storageLoadPlacement = placementsMap.get(
        placementIndices.storageIn
      );
      const logsPlacement = placementsMap.get(placementIndices.return);
      const storageStorePlacement = placementsMap.get(
        placementIndices.storageOut
      );

      console.log("logsPlacement", logsPlacement);

      const storageLoad = storageLoadPlacement?.inPts || [];
      const storageStore = storageStorePlacement?.outPts || [];
      const _logsData = logsPlacement?.outPts || [];

      // 4) Parse logs with detailed error handling (same as server/index.ts)
      const logs: Array<{
        topics: string[];
        valueDec: string;
        valueHex: string;
      }> = [];
      let prevIdx = -1;
      for (const _logData of _logsData) {
        try {
          const idx = _logData.pairedInputWireIndices?.[0] ?? -1;
          if (idx !== prevIdx) {
            logs.push({
              topics: [],
              valueDec: _logData.value?.toString() || "0",
              valueHex: _logData.valueHex || "0x0",
            });
          } else if (idx >= 0 && logs[idx]) {
            logs[idx].topics.push(_logData.valueHex || "0x0");
          }
          prevIdx = idx;
        } catch (error) {
          console.error("Error processing log data:", error, _logData);
        }
      }

      // 5) Create transformedData exactly like server/index.ts
      const transformedData = {
        from: dockerResult.from || "",
        to: dockerResult.to || "",
        logs,
        storageLoad: convertBigIntsToStrings(storageLoad),
        storageStore: convertBigIntsToStrings(storageStore),
        permutation: convertBigIntsToStrings(permutation),
        placementInstance: convertBigIntsToStrings(placementInstance),
      };

      console.log("Transformed data counts:", {
        logsCount: transformedData.logs.length,
        storageLoadCount: transformedData.storageLoad.length,
        storageStoreCount: transformedData.storageStore.length,
      });

      // 6) Transform data for client consumption (keeping existing transformation for compatibility)
      const transformedLogs = logs.map((log) => ({
        topics: log.topics.map((topic: string) =>
          topic.startsWith("0x") ? topic : `0x${topic}`
        ),
        valueDec: log.valueDec,
        valueHex: log.valueHex?.startsWith("0x")
          ? log.valueHex
          : `0x${log.valueHex}`,
      }));

      const transformedStorageLoad = transformedData.storageLoad.map(
        (item: Record<string, unknown>) => {
          const contractAddr = String(
            item.contractAddress || transformedData.to || ""
          );
          const key = String(item.key || "");
          const valueDecimal =
            typeof item.valueDecimal === "string"
              ? item.valueDecimal
              : String(item.valueDecimal || "0");
          const valueHex = String(item.valueHex || "");

          return {
            contractAddress: contractAddr.startsWith("0x")
              ? contractAddr
              : `0x${contractAddr}`,
            key: key.startsWith("0x") ? key : `0x${key}`,
            valueDecimal,
            valueHex: valueHex.startsWith("0x") ? valueHex : `0x${valueHex}`,
          };
        }
      );

      const transformedStorageStore = transformedData.storageStore.map(
        (item: Record<string, unknown>) => {
          const contractAddr = String(
            item.contractAddress || transformedData.to || ""
          );
          const key = String(item.key || "");
          const value =
            typeof item.value === "string"
              ? item.value
              : String(item.value || "0");
          const valueHex = String(item.valueHex || "");

          return {
            contractAddress: contractAddr.startsWith("0x")
              ? contractAddr
              : `0x${contractAddr}`,
            key: key.startsWith("0x") ? key : `0x${key}`,
            value,
            valueHex: valueHex.startsWith("0x") ? valueHex : `0x${valueHex}`,
          };
        }
      );

      console.log("Transformed storageLoad:", transformedStorageLoad);
      console.log("Transformed logs:", transformedLogs);
      console.log("Transformed storageStore:", transformedStorageStore);

      // Set the final data to state
      const finalData: Omit<SynthesizerResultData, "isLoading" | "error"> = {
        storageLoad: transformedStorageLoad,
        placementLogs: transformedLogs,
        storageStore: transformedStorageStore,
        evmContractAddress: transformedData.to
          ? transformedData.to.startsWith("0x")
            ? transformedData.to
            : `0x${transformedData.to}`
          : "",
        serverData: {
          permutation: transformedData.permutation
            ? JSON.stringify(transformedData.permutation)
            : null,
          placementInstance: transformedData.placementInstance
            ? JSON.stringify(transformedData.placementInstance)
            : null,
        },
      };

      setData((prev) => ({
        ...prev,
        ...finalData,
        isLoading: false,
      }));
    } catch (error) {
      console.error("Error fetching synthesizer result:", error);
      setData((prev) => ({
        ...prev,
        isLoading: false,
        error:
          error instanceof Error ? error.message : "Unknown error occurred",
      }));
    }
  }, [
    currentDockerContainer,
    transactionHash,
    executeCommand,
    convertBigIntsToStrings,
  ]);

  // Auto-fetch when transaction hash is available
  useEffect(() => {
    if (transactionHash) {
      fetchSynthesizerResult();
    }
  }, [transactionHash, fetchSynthesizerResult]);

  return {
    ...data,
    // Expose refetch function for manual refresh
    refetch: fetchSynthesizerResult,
  } as SynthesizerResultData & { refetch: () => Promise<void> };
};
