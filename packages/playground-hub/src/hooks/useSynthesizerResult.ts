import { useState, useEffect, useCallback } from "react";
import { useAtomValue } from "jotai";
import { useDocker } from "./useDocker";
import { transactionHashAtom } from "../atoms/api";

// Types matching the SynthesizerResultModal requirements
export type StorageItem = {
  contractAddress?: string;
  key: string;
  valueDecimal?: string;
  valueHex: string;
};

export type LogItem = {
  topics?: string[];
  valueDec?: string;
  valueHex: string;
};

export type StorageStoreItem = {
  contractAddress?: string;
  key: string;
  value?: string;
  valueHex: string;
};

export type ServerData = {
  permutation?: string;
  placementInstance?: string;
};

export type SynthesizerResultData = {
  storageLoad: StorageItem[];
  placementLogs: LogItem[];
  storageStore: StorageStoreItem[];
  evmContractAddress: string;
  serverData: ServerData | null;
  isLoading: boolean;
  error: string | null;
};

export const useSynthesizerResult = (): SynthesizerResultData => {
  const transactionHash = useAtomValue(transactionHashAtom);
  const { executeCommand, currentDockerContainer } = useDocker();

  const [data, setData] = useState<SynthesizerResultData>({
    storageLoad: [],
    placementLogs: [],
    storageStore: [],
    evmContractAddress: "",
    serverData: null,
    isLoading: false,
    error: null,
  });

  // Helper function to safely convert BigInts to strings (same as server)
  const convertBigIntsToStrings = (obj: unknown) => {
    try {
      return JSON.parse(
        JSON.stringify(obj, (_, value) =>
          typeof value === "bigint" ? value.toString() : value
        )
      );
    } catch (error) {
      console.error("Error converting BigInts to strings:", error);
      return [];
    }
  };

  const fetchSynthesizerResult = useCallback(async () => {
    if (!currentDockerContainer?.ID) {
      setData((prev) => ({
        ...prev,
        error: "Docker container not found. Please start the container first.",
        isLoading: false,
      }));
      return;
    }

    if (!transactionHash) {
      setData((prev) => ({
        ...prev,
        error: "Transaction hash not provided.",
        isLoading: false,
      }));
      return;
    }

    try {
      setData((prev) => ({ ...prev, isLoading: true, error: null }));

      console.log(
        "Fetching synthesizer result for transaction:",
        transactionHash
      );

      const RPC_URL =
        "https://eth-mainnet.g.alchemy.com/v2/PbqCcGx1oHN7yNaFdUJUYqPEN0QSp23S";

      console.log(`tsx index.ts ${RPC_URL} ${transactionHash}`);

      // Execute the synthesizer command in Docker container
      const result = await executeCommand(currentDockerContainer.ID, [
        "bash",
        "-c",
        `cd packages/frontend/synthesizer/examples/adaptor && 
        tsx index.ts ${RPC_URL} ${transactionHash}`,
      ]);

      console.log("Docker synthesizer result:", result);

      // Parse the result - assuming Docker returns { executionResult, permutation, placementInstance }
      let dockerResult;
      try {
        dockerResult = JSON.parse(result);
      } catch (parseError) {
        console.error("Failed to parse synthesizer result:", parseError);
        throw new Error("Invalid response format from synthesizer");
      }

      const { executionResult, permutation, placementInstance } = dockerResult;

      // Validate that we have the required data structure (same as server validation)
      if (!executionResult?.runState?.synthesizer?.placements) {
        throw new Error("No placements generated by the synthesizer.");
      }

      // Extract logs/storage from the synthesizer placements (same logic as server)
      const placementsMap = executionResult.runState.synthesizer.placements;
      console.log("Placements map size:", placementsMap.size);

      // We need to get placement indices - assuming they're available in the result
      // or we use hardcoded values like the server originally did
      // For now, let's assume we get them from the Docker result or use default values
      const placementIndices = dockerResult.placementIndices || {
        storageIn: 0, // Default values - should be replaced with actual indices
        return: 1,
        storageOut: 2,
      };

      const storageLoadPlacement = placementsMap.get(
        placementIndices.storageIn
      );
      const logsPlacement = placementsMap.get(placementIndices.return);
      const storageStorePlacement = placementsMap.get(
        placementIndices.storageOut
      );

      console.log("logsPlacement", logsPlacement);

      const storageLoad = storageLoadPlacement?.inPts || [];
      const storageStore = storageStorePlacement?.outPts || [];
      const _logsData = logsPlacement?.outPts || [];

      // Parse logs with more detailed error handling (same as server)
      const logs: Array<{
        topics: string[];
        valueDec: string;
        valueHex: string;
      }> = [];
      let prevIdx = -1;
      for (const _logData of _logsData) {
        try {
          const idx = _logData.pairedInputWireIndices?.[0] ?? -1;
          if (idx !== prevIdx) {
            logs.push({
              topics: [],
              valueDec: _logData.value?.toString() || "0",
              valueHex: _logData.valueHex || "0x0",
            });
          } else if (idx >= 0 && logs[idx]) {
            logs[idx].topics.push(_logData.valueHex || "0x0");
          }
          prevIdx = idx;
        } catch (error) {
          console.error("Error processing log data:", error, _logData);
        }
      }

      // Transform the data exactly like the server does
      const transformedData = {
        from: dockerResult.from || "",
        to: dockerResult.to || "",
        logs,
        storageLoad: convertBigIntsToStrings(storageLoad),
        storageStore: convertBigIntsToStrings(storageStore),
        permutation: convertBigIntsToStrings(permutation),
        placementInstance: convertBigIntsToStrings(placementInstance),
      };

      console.log("Transformed data counts:", {
        logsCount: transformedData.logs.length,
        storageLoadCount: transformedData.storageLoad.length,
        storageStoreCount: transformedData.storageStore.length,
      });

      // Convert to our expected format
      const finalData: Omit<SynthesizerResultData, "isLoading" | "error"> = {
        storageLoad: transformedData.storageLoad,
        placementLogs: transformedData.logs,
        storageStore: transformedData.storageStore,
        evmContractAddress: transformedData.to,
        serverData: {
          permutation: transformedData.permutation
            ? JSON.stringify(transformedData.permutation, null, 2)
            : null,
          placementInstance: transformedData.placementInstance
            ? JSON.stringify(transformedData.placementInstance, null, 2)
            : null,
        },
      };

      setData((prev) => ({
        ...prev,
        ...finalData,
        isLoading: false,
      }));
    } catch (error) {
      console.error("Error fetching synthesizer result:", error);
      setData((prev) => ({
        ...prev,
        isLoading: false,
        error:
          error instanceof Error ? error.message : "Unknown error occurred",
      }));
    }
  }, [currentDockerContainer, transactionHash, executeCommand]);

  // Auto-fetch when container and transaction hash are available
  useEffect(() => {
    if (currentDockerContainer?.ID && transactionHash) {
      fetchSynthesizerResult();
    }
  }, [currentDockerContainer?.ID, transactionHash, fetchSynthesizerResult]);

  return {
    ...data,
    // Expose refetch function for manual refresh
    refetch: fetchSynthesizerResult,
  } as SynthesizerResultData & { refetch: () => Promise<void> };
};
